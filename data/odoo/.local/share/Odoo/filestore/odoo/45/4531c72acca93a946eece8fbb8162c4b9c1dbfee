)]}'
{"version": 3, "sources": ["/web/static/src/polyfills/object.js", "/web/static/src/polyfills/array.js", "/web/static/src/module_loader.js", "/web/static/src/session.js", "/web/static/src/core/browser/cookie.js", "/web/static/src/core/utils/ui.js", "/web/static/src/legacy/js/public/minimal_dom.js", "/web/static/src/legacy/js/public/lazyloader.js", "/web_editor/static/src/js/frontend/loader_loading.js", "/website/static/src/js/content/inject_dom.js", "/website/static/src/js/content/auto_hide_menu.js", "/website/static/src/js/content/redirect.js", "/website/static/src/js/content/adapt_content.js"], "mappings": "AAAA;;;;;AAAA;AACA;AACA;AACA;AACA;ACJA;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACZA;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzPA;;;;;;;;AAAA;AACA;AACA;;;;ACFA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACrCA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACjMA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACzGA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AClLA;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnCA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACxDA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvTA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACtDA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA", "sourcesContent": ["// @odoo-module ignore\nif (!Object.hasOwn) {\n    Object.hasOwn = (obj, key) => Object.prototype.hasOwnProperty.call(obj, key);\n}\n", "// @odoo-module ignore\nif (!Array.prototype.at) {\n    Object.defineProperty(Array.prototype, \"at\", {\n        enumerable: false,\n        value: function (index) {\n            if (index >= 0) {\n                return this[index];\n            }\n            return this[this.length + index];\n        }\n    });\n}\n", "// @odoo-module ignore\n\n//-----------------------------------------------------------------------------\n// Odoo Web Boostrap Code\n//-----------------------------------------------------------------------------\n\n(function (odoo) {\n    \"use strict\";\n\n    if (odoo.loader) {\n        // Allows for duplicate calls to `module_loader`: only the first one is\n        // executed.\n        return;\n    }\n\n    class ModuleLoader {\n        /** @type {OdooModuleLoader[\"bus\"]} */\n        bus = new EventTarget();\n        /** @type {OdooModuleLoader[\"checkErrorProm\"]} */\n        checkErrorProm = null;\n        /** @type {OdooModuleLoader[\"factories\"]} */\n        factories = new Map();\n        /** @type {OdooModuleLoader[\"failed\"]} */\n        failed = new Set();\n        /** @type {OdooModuleLoader[\"jobs\"]} */\n        jobs = new Set();\n        /** @type {OdooModuleLoader[\"modules\"]} */\n        modules = new Map();\n\n        /**\n         * @param {HTMLElement} [root]\n         */\n        constructor(root) {\n            this.root = root;\n\n            const strDebug = new URLSearchParams(location.search).get(\"debug\");\n            this.debug = Boolean(strDebug && strDebug !== \"0\");\n        }\n\n        /** @type {OdooModuleLoader[\"addJob\"]} */\n        addJob(name) {\n            this.jobs.add(name);\n            this.startModules();\n        }\n\n        /** @type {OdooModuleLoader[\"define\"]} */\n        define(name, deps, factory, lazy = false) {\n            if (typeof name !== \"string\") {\n                throw new Error(`Module name should be a string, got: ${String(name)}`);\n            }\n            if (!Array.isArray(deps)) {\n                throw new Error(\n                    `Module dependencies should be a list of strings, got: ${String(deps)}`\n                );\n            }\n            if (typeof factory !== \"function\") {\n                throw new Error(`Module factory should be a function, got: ${String(factory)}`);\n            }\n            if (this.factories.has(name)) {\n                return; // Ignore duplicate modules\n            }\n            this.factories.set(name, {\n                deps,\n                fn: factory,\n                ignoreMissingDeps: globalThis.__odooIgnoreMissingDependencies,\n            });\n            if (!lazy) {\n                this.addJob(name);\n                this.checkErrorProm ||= Promise.resolve().then(() => {\n                    this.checkErrorProm = null;\n                    this.reportErrors(this.findErrors());\n                });\n            }\n        }\n\n        /** @type {OdooModuleLoader[\"findErrors\"]} */\n        findErrors(moduleNames) {\n            /**\n             * @param {Iterable<string>} currentModuleNames\n             * @param {Set<string>} visited\n             * @returns {string | null}\n             */\n            const findCycle = (currentModuleNames, visited) => {\n                for (const name of currentModuleNames || []) {\n                    if (visited.has(name)) {\n                        const cycleModuleNames = [...visited, name];\n                        return cycleModuleNames\n                            .slice(cycleModuleNames.indexOf(name))\n                            .map((j) => `\"${j}\"`)\n                            .join(\" => \");\n                    }\n                    const cycle = findCycle(dependencyGraph[name], new Set(visited).add(name));\n                    if (cycle) {\n                        return cycle;\n                    }\n                }\n                return null;\n            };\n\n            moduleNames ||= this.jobs;\n\n            /** @type {Record<string, Iterable<string>>} */\n            const dependencyGraph = Object.create(null);\n            /** @type {Set<string>} */\n            const missing = new Set();\n            /** @type {Set<string>} */\n            const unloaded = new Set();\n\n            for (const moduleName of moduleNames) {\n                const { deps, ignoreMissingDeps } = this.factories.get(moduleName);\n\n                dependencyGraph[moduleName] = deps;\n\n                if (ignoreMissingDeps) {\n                    continue;\n                }\n\n                unloaded.add(moduleName);\n                for (const dep of deps) {\n                    if (!this.factories.has(dep)) {\n                        missing.add(dep);\n                    }\n                }\n            }\n\n            const cycle = findCycle(moduleNames, new Set());\n            const errors = {};\n            if (cycle) {\n                errors.cycle = cycle;\n            }\n            if (this.failed.size) {\n                errors.failed = this.failed;\n            }\n            if (missing.size) {\n                errors.missing = missing;\n            }\n            if (unloaded.size) {\n                errors.unloaded = unloaded;\n            }\n            return errors;\n        }\n\n        /** @type {OdooModuleLoader[\"findJob\"]} */\n        findJob() {\n            for (const job of this.jobs) {\n                if (this.factories.get(job).deps.every((dep) => this.modules.has(dep))) {\n                    return job;\n                }\n            }\n            return null;\n        }\n\n        /** @type {OdooModuleLoader[\"reportErrors\"]} */\n        async reportErrors(errors) {\n            if (!Object.keys(errors).length) {\n                return;\n            }\n\n            if (errors.failed) {\n                console.error(\"The following modules failed to load because of an error:\", [\n                    ...errors.failed,\n                ]);\n            }\n            if (errors.missing) {\n                console.error(\n                    \"The following modules are needed by other modules but have not been defined, they may not be present in the correct asset bundle:\",\n                    [...errors.missing]\n                );\n            }\n            if (errors.cycle) {\n                console.error(\n                    \"The following modules could not be loaded because they form a dependency cycle:\",\n                    errors.cycle\n                );\n            }\n            if (errors.unloaded) {\n                console.error(\n                    \"The following modules could not be loaded because they have unmet dependencies, this is a secondary error which is likely caused by one of the above problems:\",\n                    [...errors.unloaded]\n                );\n            }\n\n            const document = this.root?.ownerDocument || globalThis.document;\n            if (document.readyState === \"loading\") {\n                await new Promise((resolve) =>\n                    document.addEventListener(\"DOMContentLoaded\", resolve)\n                );\n            }\n\n            if (this.debug) {\n                const style = document.createElement(\"style\");\n                style.className = \"o_module_error_banner\";\n                style.textContent = `\n                    body::before {\n                        font-weight: bold;\n                        content: \"An error occurred while loading javascript modules, you may find more information in the devtools console\";\n                        position: fixed;\n                        left: 0;\n                        bottom: 0;\n                        z-index: 100000000000;\n                        background-color: #C00;\n                        color: #DDD;\n                    }\n                `;\n                document.head.appendChild(style);\n            }\n        }\n\n        /** @type {OdooModuleLoader[\"startModules\"]} */\n        startModules() {\n            let job;\n            while ((job = this.findJob())) {\n                this.startModule(job);\n            }\n        }\n\n        /** @type {OdooModuleLoader[\"startModule\"]} */\n        startModule(name) {\n            /** @type {(dependency: string) => OdooModule} */\n            const require = (dependency) => this.modules.get(dependency);\n            this.jobs.delete(name);\n            const factory = this.factories.get(name);\n            /** @type {OdooModule | null} */\n            let module = null;\n            try {\n                module = factory.fn(require);\n            } catch (error) {\n                this.failed.add(name);\n                throw new Error(`Error while loading \"${name}\":\\n${error}`);\n            }\n            this.modules.set(name, module);\n            this.bus.dispatchEvent(\n                new CustomEvent(\"module-started\", {\n                    detail: { moduleName: name, module },\n                })\n            );\n            return module;\n        }\n    }\n\n    const loader = new ModuleLoader();\n    odoo.define = loader.define.bind(loader);\n    odoo.loader = loader;\n\n    if (odoo.debug && !loader.debug) {\n        // remove debug mode if not explicitely set in url\n        odoo.debug = \"\";\n    }\n})((globalThis.odoo ||= {}));\n", "export const session = odoo.__session_info__ || {};\ndelete odoo.__session_info__;\n", "/**\n * Utils to make use of document.cookie\n * https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies\n * As recommended, storage should not be done by the cookie\n * but with localStorage/sessionStorage\n */\n\nconst COOKIE_TTL = 24 * 60 * 60 * 365;\n\nexport const cookie = {\n    get _cookieMonster() {\n        return document.cookie;\n    },\n    set _cookieMonster(value) {\n        document.cookie = value;\n    },\n    get(str) {\n        const parts = this._cookieMonster.split(\"; \");\n        for (const part of parts) {\n            const [key, value] = part.split(/=(.*)/);\n            if (key === str) {\n                return value || \"\";\n            }\n        }\n    },\n    set(key, value, ttl = COOKIE_TTL) {\n        let fullCookie = [];\n        if (value !== undefined) {\n            fullCookie.push(`${key}=${value}`);\n        }\n        fullCookie = fullCookie.concat([\"path=/\", `max-age=${Math.floor(ttl)}`]);\n        this._cookieMonster = fullCookie.join(\"; \");\n    },\n    delete(key) {\n        this.set(key, \"kill\", 0);\n    },\n};\n", "/**\n * @typedef Position\n * @property {number} x\n * @property {number} y\n */\n\n/**\n * @param {Iterable<HTMLElement>} elements\n * @param {Position} targetPos\n * @returns {HTMLElement | null}\n */\nexport function closest(elements, targetPos) {\n    let closestEl = null;\n    let closestDistance = Infinity;\n    for (const el of elements) {\n        const rect = el.getBoundingClientRect();\n        const distance = getQuadrance(rect, targetPos);\n        if (!closestEl || distance < closestDistance) {\n            closestEl = el;\n            closestDistance = distance;\n        }\n    }\n    return closestEl;\n}\n\n/**\n * rough approximation of a visible element. not perfect (does not take into\n * account opacity = 0 for example), but good enough for our purpose\n *\n * @param {Element} el\n * @returns {boolean}\n */\nexport function isVisible(el) {\n    if (el === document || el === window) {\n        return true;\n    }\n    if (!el) {\n        return false;\n    }\n    let _isVisible = false;\n    if (\"offsetWidth\" in el && \"offsetHeight\" in el) {\n        _isVisible = el.offsetWidth > 0 && el.offsetHeight > 0;\n    } else if (\"getBoundingClientRect\" in el) {\n        // for example, svgelements\n        const rect = el.getBoundingClientRect();\n        _isVisible = rect.width > 0 && rect.height > 0;\n    }\n    if (!_isVisible && getComputedStyle(el).display === \"contents\") {\n        for (const child of el.children) {\n            if (isVisible(child)) {\n                return true;\n            }\n        }\n    }\n    return _isVisible;\n}\n\n/**\n * @param {DOMRect} rect\n * @param {Position} pos\n * @returns {number}\n */\nexport function getQuadrance(rect, pos) {\n    let q = 0;\n    if (pos.x < rect.x) {\n        q += (rect.x - pos.x) ** 2;\n    } else if (rect.x + rect.width < pos.x) {\n        q += (pos.x - (rect.x + rect.width)) ** 2;\n    }\n    if (pos.y < rect.y) {\n        q += (rect.y - pos.y) ** 2;\n    } else if (rect.y + rect.height < pos.y) {\n        q += (pos.y - (rect.y + rect.height)) ** 2;\n    }\n    return q;\n}\n\n/**\n * @param {Element} activeElement\n * @param {String} selector\n * @returns all selected and visible elements present in the activeElement\n */\nexport function getVisibleElements(activeElement, selector) {\n    const visibleElements = [];\n    /** @type {NodeListOf<HTMLElement>} */\n    const elements = activeElement.querySelectorAll(selector);\n    for (const el of elements) {\n        if (isVisible(el)) {\n            visibleElements.push(el);\n        }\n    }\n    return visibleElements;\n}\n\n/**\n * @param {Iterable<HTMLElement>} elements\n * @param {Partial<DOMRect>} targetRect\n * @returns {HTMLElement[]}\n */\nexport function touching(elements, targetRect) {\n    const r1 = { x: 0, y: 0, width: 0, height: 0, ...targetRect };\n    return [...elements].filter((el) => {\n        const r2 = el.getBoundingClientRect();\n        return (\n            r2.x + r2.width >= r1.x &&\n            r2.x <= r1.x + r1.width &&\n            r2.y + r2.height >= r1.y &&\n            r2.y <= r1.y + r1.height\n        );\n    });\n}\n\n// -----------------------------------------------------------------------------\n// Get Tabable Elements\n// -----------------------------------------------------------------------------\n// TODISCUSS:\n//  - leave the following in this file ?\n//  - redefine this selector in tests env with \":not(#qunit *)\" ?\n\n// Following selector is based on this spec: https://html.spec.whatwg.org/multipage/interaction.html#dom-tabindex\nconst TABABLE_SELECTOR = [\n    \"[tabindex]\",\n    \"a\",\n    \"area\",\n    \"button\",\n    \"frame\",\n    \"iframe\",\n    \"input\",\n    \"object\",\n    \"select\",\n    \"textarea\",\n    \"details > summary:nth-child(1)\",\n]\n    .map((sel) => `${sel}:not([tabindex=\"-1\"]):not(:disabled)`)\n    .join(\",\");\n\n/**\n * Returns all focusable elements in the given container.\n *\n * @param {HTMLElement} [container=document.body]\n */\nexport function getTabableElements(container = document.body) {\n    const elements = [...container.querySelectorAll(TABABLE_SELECTOR)].filter(isVisible);\n    /** @type {Record<number, HTMLElement[]>} */\n    const byTabIndex = {};\n    for (const el of [...elements]) {\n        if (!byTabIndex[el.tabIndex]) {\n            byTabIndex[el.tabIndex] = [];\n        }\n        byTabIndex[el.tabIndex].push(el);\n    }\n\n    const withTabIndexZero = byTabIndex[0] || [];\n    delete byTabIndex[0];\n    return [...Object.values(byTabIndex).flat(), ...withTabIndexZero];\n}\n\nexport function getNextTabableElement(container = document.body) {\n    const tabableElements = getTabableElements(container);\n    const index = tabableElements.indexOf(document.activeElement);\n    return index === -1 ? tabableElements[0] : tabableElements[index + 1] || null;\n}\n\nexport function getPreviousTabableElement(container = document.body) {\n    const tabableElements = getTabableElements(container);\n    const index = tabableElements.indexOf(document.activeElement);\n    return index === -1\n        ? tabableElements[tabableElements.length - 1]\n        : tabableElements[index - 1] || null;\n}\n\n/**\n * Gives the button a loading effect by disabling it and adding a `fa` spinner\n * icon. The existing button `fa` icons will be hidden through css.\n *\n * @param {HTMLElement} btnEl - the button to disable/load\n * @return {function} a callback function that will restore the button to its\n *         initial state\n */\nexport function addLoadingEffect(btnEl) {\n    // Note that pe-none is used alongside \"disabled\" so that the behavior is\n    // the same on links not using the \"btn\" class -> pointer-events disabled.\n    btnEl.classList.add(\"o_btn_loading\", \"disabled\", \"pe-none\");\n    btnEl.disabled = true;\n    const loaderEl = document.createElement(\"span\");\n    loaderEl.classList.add(\"fa\", \"fa-refresh\", \"fa-spin\", \"me-2\");\n    btnEl.prepend(loaderEl);\n    return () => {\n        btnEl.classList.remove(\"o_btn_loading\", \"disabled\", \"pe-none\");\n        btnEl.disabled = false;\n        loaderEl.remove();\n    };\n}\n", "/** @odoo-module **/\n\nimport { addLoadingEffect } from '@web/core/utils/ui';\n\nexport const DEBOUNCE = 400;\nexport const BUTTON_HANDLER_SELECTOR = 'a, button, input[type=\"submit\"], input[type=\"button\"], .btn';\n\n/**\n * Protects a function which is to be used as a handler by preventing its\n * execution for the duration of a previous call to it (including async\n * parts of that call).\n *\n * Limitation: as the handler is ignored during async actions,\n * the 'preventDefault' or 'stopPropagation' calls it may want to do\n * will be ignored too. Using the 'preventDefault' and 'stopPropagation'\n * arguments solves that problem.\n *\n * @param {function} fct\n *      The function which is to be used as a handler. If a promise\n *      is returned, it is used to determine when the handler's action is\n *      finished. Otherwise, the return is used as jQuery uses it.\n * @param {function|boolean} preventDefault\n * @param {function|boolean} stopPropagation\n * @param {function|boolean} stopImmediatePropagation\n */\nexport function makeAsyncHandler(fct, preventDefault, stopPropagation, stopImmediatePropagation) {\n    let pending = false;\n    function _isLocked() {\n        return pending;\n    }\n    function _lock() {\n        pending = true;\n    }\n    function _unlock() {\n        pending = false;\n    }\n    return function (ev) {\n        if (preventDefault === true || preventDefault && preventDefault()) {\n            ev.preventDefault();\n        }\n        if (stopPropagation === true || stopPropagation && stopPropagation()) {\n            ev.stopPropagation();\n        }\n        if (stopImmediatePropagation === true || stopImmediatePropagation && stopImmediatePropagation()) {\n            ev.stopImmediatePropagation();\n        }\n\n        if (_isLocked()) {\n            // If a previous call to this handler is still pending, ignore\n            // the new call.\n            return;\n        }\n\n        _lock();\n        const result = fct.apply(this, arguments);\n        Promise.resolve(result).finally(_unlock);\n        return result;\n    };\n}\n\n/**\n * Creates a debounced version of a function to be used as a button click\n * handler. Also improves the handler to disable the button for the time of\n * the debounce and/or the time of the async actions it performs.\n *\n * Limitation: if two handlers are put on the same button, the button will\n * become enabled again once any handler's action finishes (multiple click\n * handlers should however not be bound to the same button).\n *\n * @param {function} fct\n *      The function which is to be used as a button click handler. If a\n *      promise is returned, it is used to determine when the button can be\n *      re-enabled. Otherwise, the return is used as jQuery uses it.\n * @param {function|boolean} preventDefault\n * @param {function|boolean} stopPropagation\n * @param {function|boolean} stopImmediatePropagation\n */\nexport function makeButtonHandler(fct, preventDefault, stopPropagation, stopImmediatePropagation) {\n    // Fallback: if the final handler is not bound to a button, at least\n    // make it an async handler (also handles the case where some events\n    // might ignore the disabled state of the button).\n    fct = makeAsyncHandler(fct, preventDefault, stopPropagation, stopImmediatePropagation);\n\n    return function (ev) {\n        const result = fct.apply(this, arguments);\n\n        const buttonEl = ev.target.closest(BUTTON_HANDLER_SELECTOR);\n        if (!(buttonEl instanceof HTMLElement)) {\n            return result;\n        }\n\n        // Disable the button for the duration of the handler's action\n        // or at least for the duration of the click debounce. This makes\n        // a 'real' debounce creation useless. Also, during the debouncing\n        // part, the button is disabled without any visual effect.\n        buttonEl.classList.add(\"pe-none\");\n        new Promise(resolve => setTimeout(resolve, DEBOUNCE)).then(() => {\n            buttonEl.classList.remove(\"pe-none\");\n            const restore = addLoadingEffect(buttonEl);\n            return Promise.resolve(result).then(restore, restore);\n        });\n\n        return result;\n    };\n}\n", "import {\n    BUTTON_HANDLER_SELECTOR,\n    makeAsyncHandler,\n    makeButtonHandler,\n} from '@web/legacy/js/public/minimal_dom';\n\n// Track when all JS files have been lazy loaded. Will allow to unblock the\n// related DOM sections when the whole JS have been loaded and executed.\nlet allScriptsLoadedResolve = null;\nconst _allScriptsLoaded = new Promise(resolve => {\n    allScriptsLoadedResolve = resolve;\n}).then(stopWaitingLazy);\n\nconst retriggeringWaitingProms = [];\n/**\n * Function to use as an event handler to replay the incoming event after the\n * whole lazy JS has been loaded. Note that blocking the incoming event is left\n * up to the caller (i.e. a potential wrapper, @see waitLazy).\n *\n * @param {Event} ev\n * @returns {Promise}\n */\nasync function waitForLazyAndRetrigger(ev) {\n    // Wait for the lazy JS to be loaded before re-triggering the event.\n    const targetEl = ev.target;\n    await _allScriptsLoaded;\n    // Loaded scripts were able to add a delay to wait for before re-triggering\n    // events: we wait for it here.\n    await Promise.all(retriggeringWaitingProms);\n\n    // At the end of the current execution queue, retrigger the event. Note that\n    // the event is reconstructed: this is necessary in some cases, e.g. submit\n    // buttons. Probably because the event was originally defaultPrevented.\n    setTimeout(() => {\n        // Extra safety check: the element might have been removed from the DOM\n        if (targetEl.isConnected) {\n            targetEl.dispatchEvent(new ev.constructor(ev.type, ev));\n        }\n    }, 0);\n}\n\nconst loadingEffectHandlers = [];\n/**\n * Adds the given event listener and saves it for later removal.\n *\n * @param {HTMLElement} el\n * @param {string} type\n * @param {Function} handler\n */\nfunction registerLoadingEffectHandler(el, type, handler) {\n    el.addEventListener(type, handler, {capture: true});\n    loadingEffectHandlers.push({el, type, handler});\n}\n\nlet waitingLazy = false;\n\n/**\n * Automatically adds a loading effect on clicked buttons (that were not marked\n * with a specific class). Once the whole JS has been loaded, the events will be\n * triggered again.\n *\n * For forms, we automatically prevent submit events (since can be triggered\n * without click on a button) but we do not retrigger them (could be duplicate\n * with re-trigger of a click on a submit button otherwise). However, submitting\n * a form in any way should most of the time simulate a click on the submit\n * button if any anyway.\n *\n * @see stopWaitingLazy\n */\nfunction waitLazy() {\n    if (waitingLazy) {\n        return;\n    }\n    waitingLazy = true;\n\n    document.body.classList.add('o_lazy_js_waiting');\n\n    // TODO should probably find the wrapwrap another way but in future versions\n    // the element will be gone anyway.\n    const mainEl = document.getElementById('wrapwrap') || document.body;\n    const loadingEffectButtonEls = [...mainEl.querySelectorAll(BUTTON_HANDLER_SELECTOR)]\n        // We target all buttons but...\n        .filter(el => {\n            // ... we allow to disable the effect by adding a specific class if\n            // needed. Note that if some non-lazy loaded code is adding an event\n            // handler on some buttons, it means that if they do not have that\n            // class, they will show a loading effect and not do anything until\n            // lazy JS is loaded anyway. This is not ideal, especially since\n            // this was added as a stable fix/imp, but this is a compromise: on\n            // next page visits, the cache should limit to effect of the lazy\n            // loading anyway.\n            return !el.classList.contains('o_no_wait_lazy_js')\n                // ... we also allow do not consider links with a href which is\n                // not \"#\". They could be linked to handlers that prevent their\n                // default behavior but we consider that following the link\n                // should still be relevant in that case.\n                && !(el.nodeName === 'A' && el.href && el.getAttribute('href') !== '#');\n        });\n    // Note: this is a limitation/a \"risk\" to only block and retrigger those\n    // specific event types.\n    const loadingEffectEventTypes = ['mouseover', 'mouseenter', 'mousedown', 'mouseup', 'click', 'mouseout', 'mouseleave'];\n    for (const buttonEl of loadingEffectButtonEls) {\n        for (const eventType of loadingEffectEventTypes) {\n            const loadingEffectHandler = eventType === 'click'\n                ? makeButtonHandler(waitForLazyAndRetrigger, true, true, true)\n                : makeAsyncHandler(waitForLazyAndRetrigger, true, true, true);\n            registerLoadingEffectHandler(buttonEl, eventType, loadingEffectHandler);\n        }\n    }\n\n    for (const formEl of document.querySelectorAll('form:not(.o_no_wait_lazy_js)')) {\n        registerLoadingEffectHandler(formEl, 'submit', ev => {\n            ev.preventDefault();\n            ev.stopImmediatePropagation();\n        });\n    }\n}\n/**\n * Undo what @see waitLazy did.\n */\nfunction stopWaitingLazy() {\n    if (!waitingLazy) {\n        return;\n    }\n    waitingLazy = false;\n\n    document.body.classList.remove('o_lazy_js_waiting');\n\n    for (const { el, type, handler } of loadingEffectHandlers) {\n        el.removeEventListener(type, handler, {capture: true});\n    }\n}\n\n// Start waiting for lazy loading as soon as the DOM is available\nif (document.readyState !== 'loading') {\n    waitLazy();\n} else {\n    document.addEventListener('DOMContentLoaded', function () {\n        waitLazy();\n    });\n}\n\n// As soon as the document is fully loaded, start loading the whole remaining JS\nif (document.readyState === 'complete') {\n    setTimeout(_loadScripts, 0);\n} else {\n    window.addEventListener('load', function () {\n        setTimeout(_loadScripts, 0);\n    });\n}\n\n/**\n * @param {DOMElement[]} scripts\n * @param {integer} index\n */\nfunction _loadScripts(scripts, index) {\n    if (scripts === undefined) {\n        scripts = document.querySelectorAll('script[data-src]');\n    }\n    if (index === undefined) {\n        index = 0;\n    }\n    if (index >= scripts.length) {\n        allScriptsLoadedResolve();\n        return;\n    }\n    const script = scripts[index];\n    script.addEventListener('load', _loadScripts.bind(this, scripts, index + 1));\n    script.setAttribute('defer', 'defer');\n    script.src = script.dataset.src;\n    script.removeAttribute('data-src');\n}\n\nexport default {\n    loadScripts: _loadScripts,\n    allScriptsLoaded: _allScriptsLoaded,\n    registerPageReadinessDelay: retriggeringWaitingProms.push.bind(retriggeringWaitingProms),\n};\n", "// @odoo-module ignore\n\n(function () {\n'use strict';\n\n/**\n * This file makes sure textarea elements with a specific editor class are\n * tweaked as soon as the DOM is ready so that they appear to be loading.\n *\n * They must then be loaded using standard Odoo modules system. In particular,\n * @see @web_editor/js/frontend/loadWysiwygFromTextarea\n */\n\ndocument.addEventListener('DOMContentLoaded', () => {\n    // Standard loop for better browser support\n    var textareaEls = document.querySelectorAll('textarea.o_wysiwyg_loader');\n    for (var i = 0; i < textareaEls.length; i++) {\n        var textarea = textareaEls[i];\n        var wrapper = document.createElement('div');\n        wrapper.classList.add('position-relative', 'o_wysiwyg_textarea_wrapper');\n\n        var loadingElement = document.createElement('div');\n        loadingElement.classList.add('o_wysiwyg_loading');\n        var loadingIcon = document.createElement('i');\n        loadingIcon.classList.add('text-600', 'text-center',\n            'fa', 'fa-circle-o-notch', 'fa-spin', 'fa-2x');\n        loadingElement.appendChild(loadingIcon);\n        wrapper.appendChild(loadingElement);\n\n        textarea.parentNode.insertBefore(wrapper, textarea);\n        wrapper.insertBefore(textarea, loadingElement);\n    }\n});\n\n})();\n", "/** @odoo-module */\n\nimport { cookie as cookieManager } from \"@web/core/browser/cookie\";\nimport { session } from \"@web/session\";\n\n/**\n * Unhide elements that are hidden by default and that should be visible\n * according to the snippet visibility option.\n */\nexport function unhideConditionalElements() {\n    // Create CSS rules in a dedicated style tag according to the snippet\n    // visibility option's computed ones (saved as data attributes).\n    const styleEl = document.createElement('style');\n    styleEl.id = \"conditional_visibility\";\n    document.head.appendChild(styleEl);\n    const conditionalEls = document.querySelectorAll('[data-visibility=\"conditional\"]');\n    for (const conditionalEl of conditionalEls) {\n        const selectors = conditionalEl.dataset.visibilitySelectors;\n        styleEl.sheet.insertRule(`${selectors} { display: none !important; }`);\n    }\n\n    // Now remove the classes that makes them always invisible\n    for (const conditionalEl of conditionalEls) {\n        conditionalEl.classList.remove('o_conditional_hidden');\n    }\n}\n\nexport function setUtmsHtmlDataset() {\n    const htmlEl = document.documentElement;\n    const cookieNamesToDataNames = {\n        'utm_source': 'utmSource',\n        'utm_medium': 'utmMedium',\n        'utm_campaign': 'utmCampaign',\n    };\n    for (const [name, dsName] of Object.entries(cookieNamesToDataNames)) {\n        const cookie = cookieManager.get(`odoo_${name}`);\n        if (cookie) {\n            // Remove leading and trailing \" and '\n            htmlEl.dataset[dsName] = cookie.replace(/(^[\"']|[\"']$)/g, '');\n        }\n    }\n}\n\ndocument.addEventListener('DOMContentLoaded', () => {\n    // Transfer cookie/session data as HTML element's attributes so that CSS\n    // selectors can be based on them.\n    setUtmsHtmlDataset();\n    const htmlEl = document.documentElement;\n    const country = session.geoip_country_code;\n    if (country) {\n        htmlEl.dataset.country = country;\n    }\n    htmlEl.dataset.logged = !session.is_website_user;\n\n    unhideConditionalElements();\n});\n", "/** @odoo-module **/\n\nconst BREAKPOINT_SIZES = {sm: '575', md: '767', lg: '991', xl: '1199', xxl: '1399'};\n\n/**\n * Creates an automatic 'more' dropdown-menu for a set of navbar items.\n *\n * @param {HTMLElement} el\n * @param {Object} [options]\n * @param {string} [options.unfoldable='none'] selector for items that do not\n * need to be added to dropdown-menu.\n * @param {Array} [options.images=[]] images to wait for before menu update.\n * @param {Array} [options.loadingStyleClasses=[]] list of CSS classes to add while\n * updating the menu.\n * @param {function} [options.autoClose] returns a value that represents the\n * \"auto-close\" behaviour of the dropdown (e.g. used to prevent auto-closing in\n * \"edit\" mode).\n*/\nasync function autoHideMenu(el, options) {\n    if (!el) {\n        return;\n    }\n    const navbar = el.closest('.navbar');\n    // Get breakpoint related information from the navbar to correctly handle\n    // the \"auto-hide\" on mobile menu.\n    const [breakpoint = 'md'] = navbar ? Object.keys(BREAKPOINT_SIZES)\n        .filter(suffix => navbar.classList.contains(`navbar-expand-${suffix}`)) : [];\n    const isNoHamburgerMenu = !!navbar && navbar.classList.contains('navbar-expand');\n    const minSize = BREAKPOINT_SIZES[breakpoint];\n    let isExtraMenuOpen = false;\n\n    options = Object.assign({\n        unfoldable: 'none',\n        images: [],\n        loadingStyleClasses: [],\n        autoClose: () => true,\n    }, options || {});\n\n    const isUserNavbar = el.parentElement.classList.contains('o_main_navbar');\n    const dropdownSubMenuClasses = ['show', 'border-0', 'position-static'];\n    const dropdownToggleClasses = ['h-auto', 'py-2', 'text-secondary'];\n    const autoMarginLeftRegex = /\\bm[sx]?(?:-(?:sm|md|lg|xl|xxl))?-auto\\b/; // grep: ms-auto mx-auto\n    const autoMarginRightRegex = /\\bm[ex]?(?:-(?:sm|md|lg|xl|xxl))?-auto\\b/; // grep: me-auto mx-auto\n    var extraItemsToggle = null;\n    const afterFontsloading = new Promise((resolve) => {\n        if (document.fonts) {\n            document.fonts.ready.then(resolve);\n        } else {\n            // IE: don't wait more than max .15s.\n            setTimeout(resolve, 150);\n        }\n    });\n    afterFontsloading.then(_adapt);\n\n    if (options.images.length) {\n        await _afterImagesLoading(options.images);\n        _adapt();\n    }\n\n    let pending = false;\n    let refreshId = null;\n    const onRefresh = () => {\n        if (pending) {\n            refreshId = window.requestAnimationFrame(onRefresh);\n            _adapt();\n            pending = false;\n        } else {\n            refreshId = null;\n        }\n    };\n    // This should throttle the `_adapt()` method to the browser's refresh\n    // rate. The first menu adaptation is always executed immediately.\n    const throttleAdapt = () => {\n        if (refreshId === null) {\n            refreshId = window.requestAnimationFrame(onRefresh);\n            _adapt();\n        } else {\n            pending = true;\n        }\n    };\n\n    window.addEventListener('resize', throttleAdapt);\n\n    function _restore() {\n        if (!extraItemsToggle) {\n            return;\n        }\n        // Move extra menu items from dropdown-menu to menu element in the same order.\n        [...extraItemsToggle.querySelector('.dropdown-menu').children].forEach((item) => {\n            if (!isUserNavbar) {\n                item.classList.add('nav-item');\n                const itemLink = item.querySelector('.dropdown-item');\n                if (itemLink) {\n                    itemLink.classList.remove('dropdown-item');\n                    itemLink.classList.add('nav-link');\n                }\n            } else {\n                item.classList.remove('dropdown-item');\n                const dropdownSubMenu = item.querySelector('.dropdown-menu');\n                const dropdownSubMenuButton = item.querySelector('.dropdown-toggle');\n                if (dropdownSubMenu) {\n                    dropdownSubMenu.classList.remove(...dropdownSubMenuClasses);\n                }\n                if (dropdownSubMenuButton) {\n                    dropdownSubMenuButton.classList.remove(...dropdownToggleClasses);\n                }\n            }\n            el.insertBefore(item, extraItemsToggle);\n        });\n        extraItemsToggle.remove();\n        extraItemsToggle = null;\n    }\n\n    function _adapt() {\n        const wysiwyg = window.$ && $('#wrapwrap').data('wysiwyg');\n        const odooEditor = wysiwyg && wysiwyg.odooEditor;\n        if (odooEditor) {\n            odooEditor.observerUnactive(\"adapt\");\n            odooEditor.withoutRollback(__adapt);\n            odooEditor.observerActive(\"adapt\");\n            return;\n        }\n        __adapt();\n    }\n\n    function __adapt() {\n        if (options.loadingStyleClasses.length) {\n            el.classList.add(...options.loadingStyleClasses);\n        }\n        // The goal here is to get the state of the extra menu dropdown if it is\n        // there, which will be restored after the menu adaptation.\n        const extraMenuEl = _getExtraMenuEl();\n        isExtraMenuOpen = extraMenuEl && extraMenuEl.classList.contains(\"show\");\n        _restore();\n\n        // Ignore invisible/toggleable top menu element & small viewports.\n        if (!el.getClientRects().length || el.closest('.show')\n            || (window.matchMedia(`(max-width: ${minSize}px)`).matches && !isNoHamburgerMenu)) {\n            return _endAutoMoreMenu();\n        }\n\n        let unfoldableItems = [];\n        const items = [...el.children].filter((node) => {\n            if (node.matches && !node.matches(options.unfoldable)) {\n                return true;\n            }\n            unfoldableItems.push(node);\n            return false;\n        });\n        var nbItems = items.length;\n        var menuItemsWidth = items.reduce((sum, el) => sum + computeFloatOuterWidthWithMargins(el, true, true, false), 0);\n        let maxWidth = 0;\n\n        if (!maxWidth) {\n            maxWidth = computeFloatOuterWidthWithMargins(el, true, true, true);\n            var style = window.getComputedStyle(el);\n            maxWidth -= (parseFloat(style.paddingLeft) + parseFloat(style.paddingRight) + parseFloat(style.borderLeftWidth) + parseFloat(style.borderRightWidth));\n            maxWidth -= unfoldableItems.reduce((sum, el) => sum + computeFloatOuterWidthWithMargins(el, true, true, false), 0);\n        }\n        // Ignore if there is no overflow.\n        if (maxWidth - menuItemsWidth >= -0.001) {\n            return _endAutoMoreMenu();\n        }\n\n        const dropdownMenu = _addExtraItemsButton(items[nbItems - 1].nextElementSibling);\n        menuItemsWidth += computeFloatOuterWidthWithMargins(extraItemsToggle, true, true, false);\n        do {\n            menuItemsWidth -= computeFloatOuterWidthWithMargins(items[--nbItems], true, true, false);\n        } while (!(maxWidth - menuItemsWidth >= -0.001) && (nbItems > 0));\n\n        const extraItems = items.slice(nbItems);\n        extraItems.forEach((el) => {\n            if (!isUserNavbar) {\n                const navLink = el.querySelector('.nav-link, a');\n                el.classList.remove('nav-item');\n                if (navLink) {\n                    navLink.classList.remove('nav-link');\n                    navLink.classList.add('dropdown-item');\n                }\n            } else {\n                const dropdownSubMenu = el.querySelector('.dropdown-menu');\n                const dropdownSubMenuButton = el.querySelector('.dropdown-toggle');\n                el.classList.add('dropdown-item', 'p-0');\n                if (dropdownSubMenu) {\n                    dropdownSubMenu.classList.add(...dropdownSubMenuClasses);\n                }\n                if (dropdownSubMenuButton) {\n                    dropdownSubMenuButton.classList.add(...dropdownToggleClasses);\n                }\n            }\n            dropdownMenu.appendChild(el);\n        });\n        _endAutoMoreMenu();\n    }\n\n    function computeFloatOuterWidthWithMargins(el, mLeft, mRight, considerAutoMargins) {\n        var rect = el.getBoundingClientRect();\n        var style = window.getComputedStyle(el);\n        var outerWidth = rect.right - rect.left;\n        const isRTL = style.direction === 'rtl';\n        if (mLeft !== false && (considerAutoMargins || !(isRTL ? autoMarginRightRegex : autoMarginLeftRegex).test(el.getAttribute('class')))) {\n            outerWidth += parseFloat(style.marginLeft);\n        }\n        if (mRight !== false && (considerAutoMargins || !(isRTL ? autoMarginLeftRegex : autoMarginRightRegex).test(el.getAttribute('class')))) {\n            outerWidth += parseFloat(style.marginRight);\n        }\n        // Would be NaN for invisible elements for example\n        return isNaN(outerWidth) ? 0 : outerWidth;\n    }\n\n    function _addExtraItemsButton(target) {\n        let dropdownMenu = document.createElement('div');\n        extraItemsToggle = dropdownMenu.cloneNode();\n        const extraItemsToggleIcon = document.createElement('i');\n        const extraItemsToggleLink = document.createElement('a');\n\n        dropdownMenu.className = 'dropdown-menu';\n        extraItemsToggle.className = 'nav-item dropdown o_extra_menu_items';\n        extraItemsToggle.setAttribute(\"role\", \"presentation\");\n        extraItemsToggleIcon.className = 'fa fa-plus';\n        const extraItemsToggleAriaLabel = el.closest(\"[data-extra-items-toggle-aria-label]\")\n            ?.dataset.extraItemsToggleAriaLabel;\n        Object.entries({\n            role: 'menuitem',\n            href: '#',\n            class: 'nav-link dropdown-toggle o-no-caret',\n            'data-bs-toggle': 'dropdown',\n            'aria-expanded': false,\n            'aria-label': extraItemsToggleAriaLabel || \" \",\n        }).forEach(([key, value]) => {\n            extraItemsToggleLink.setAttribute(key, value);\n        });\n\n        extraItemsToggleLink.appendChild(extraItemsToggleIcon);\n        extraItemsToggle.appendChild(extraItemsToggleLink);\n        extraItemsToggle.appendChild(dropdownMenu);\n        el.insertBefore(extraItemsToggle, target);\n        if (!options.autoClose()) {\n            extraItemsToggleLink.setAttribute(\"data-bs-auto-close\", \"outside\");\n        }\n        return dropdownMenu;\n    }\n\n    function _afterImagesLoading(images) {\n        const defs = images.map((image) => {\n            if (image.complete || !image.getClientRects().length) {\n                return null;\n            }\n            return new Promise(function (resolve, reject) {\n                if (!image.width) {\n                    // The purpose of the 'o_menu_image_placeholder' class is to add a default\n                    // size to non loaded images (on the first update) to prevent flickering.\n                    image.classList.add('o_menu_image_placeholder');\n                }\n                image.addEventListener('load', () => {\n                    image.classList.remove('o_menu_image_placeholder');\n                    resolve();\n                });\n            });\n        });\n        return Promise.all(defs);\n    }\n\n    function _getExtraMenuEl() {\n        return el.querySelector(\".o_extra_menu_items .dropdown-toggle\");\n    }\n\n    function _endAutoMoreMenu() {\n        const extraMenuEl = _getExtraMenuEl();\n        if (extraMenuEl && isExtraMenuOpen) {\n            extraMenuEl.click();\n        }\n        el.classList.remove(...options.loadingStyleClasses);\n    }\n}\n\n/**\n * Auto adapt the header layout so that elements are not wrapped on a new line.\n */\ndocument.addEventListener('DOMContentLoaded', async () => {\n    const header = document.querySelector('header#top');\n    if (header) {\n        const topMenu = header.querySelector(\".top_menu\");\n        const unfoldable = \".divider, .divider ~ li, .o_no_autohide_item, .js_language_selector\";\n        if (!topMenu.querySelector(`:scope > :not(${unfoldable})`)\n                || header.classList.contains(\"o_no_autohide_menu\")) {\n            topMenu.classList.remove('o_menu_loading');\n            return;\n        }\n        const excludedImagesSelector = '.o_mega_menu, .o_offcanvas_logo_container, .o_lang_flag';\n        const excludedImages = [...header.querySelectorAll(excludedImagesSelector)];\n        const images = [...header.querySelectorAll('img')].filter((img) => {\n            excludedImages.forEach(node => {\n                if (node.contains(img)) {\n                    return false;\n                }\n            });\n            return img.matches && !img.matches(excludedImagesSelector);\n        });\n        autoHideMenu(topMenu, {\n            unfoldable: unfoldable,\n            images: images,\n            loadingStyleClasses: ['o_menu_loading'],\n            // The \"auto-hide\" menu is closed when clicking inside the extra\n            // menu items. The goal here is to prevent this default behaviour\n            // on \"edit\" mode to allow correct editing of extra menu items, mega\n            // menu content...\n            autoClose: () => !document.body.classList.contains(\"editor_enable\"),\n        });\n    }\n});\n", "/** @odoo-module */\n\nimport { session } from '@web/session';\n\n/**\n * This script, served with frontend pages, displays buttons in the top left\n * corner to provide the authenticated user an access to his odoo backend.\n * In the case of the page being viewed in the website_preview client action,\n * it will forward some events to its parent.\n */\ndocument.addEventListener('DOMContentLoaded', () => {\n    if (session.is_website_user) {\n        return;\n    }\n\n    if (!window.frameElement) {\n        const frontendToBackendNavEl = document.querySelector('.o_frontend_to_backend_nav');\n        if (frontendToBackendNavEl) {\n            frontendToBackendNavEl.classList.add('d-flex');\n            frontendToBackendNavEl.classList.remove('d-none');\n        }\n        // Auto redirect to frontend if edit/translation mode is requested\n        const currentUrl = new URL(window.location.href);\n        currentUrl.pathname = `/@${currentUrl.pathname}`;\n        if (currentUrl.searchParams.get('enable_editor') || currentUrl.searchParams.get('edit_translations')) {\n            document.body.innerHTML = '';\n            window.location.replace(currentUrl.href);\n            return;\n        }\n        const backendEditBtnEl = document.querySelector('.o_frontend_to_backend_edit_btn');\n        if (backendEditBtnEl) {\n            backendEditBtnEl.href = currentUrl.href;\n            document.addEventListener(\"keydown\", ev => {\n                if (ev.key === \"a\" && ev.altKey) {\n                    currentUrl.searchParams.set('enable_editor', 1);\n                    window.location.replace(currentUrl.href);\n                }\n            }, true);\n        }\n    } else {\n        const backendUserDropdownLinkEl = document.getElementById('o_backend_user_dropdown_link');\n        if (backendUserDropdownLinkEl) {\n            backendUserDropdownLinkEl.classList.add('d-none');\n            backendUserDropdownLinkEl.classList.remove('d-flex');\n        }\n        // Multiple reasons to do this:\n        // - It seems like DOMContentLoaded doesn't always trigger when\n        //   listened from the parent window\n        // - Having an event that's fire only when the page is from Odoo avoids\n        //   weird behaviours. (e.g. if we want to clear out the iframe, it might\n        //   fire an DOMContentLoaded on a non odoo page)\n        window.frameElement.dispatchEvent(new CustomEvent('OdooFrameContentLoaded'));\n    }\n});\n", "/** @odoo-module */\n\ndocument.addEventListener('DOMContentLoaded', () => {\n    const htmlEl = document.documentElement;\n    const editTranslations = !!htmlEl.dataset.edit_translations;\n    // Hack: on translation editor, textareas with translatable text content\n    // will get a `<span/>` as translation value which stays visible until\n    // the values are updated on the editor. The same issue was fixed on CSS\n    // for `placeholder` and `value` attributes (since we can get the elements\n    // with attribute translation on CSS). But here, we need to hide the text\n    // on JS until the editor's code sets the right values on textareas.\n    if (editTranslations) {\n        [...document.querySelectorAll('textarea')].map(textarea => {\n            if (textarea.value.indexOf('data-oe-translation-source-sha') !== -1) {\n                textarea.classList.add('o_text_content_invisible');\n            }\n        });\n    }\n    // Hack: we move the '#o_search_modal' from the '#header' to\n    // '#o_search_modal_block'. Without this change, when the header has a\n    // 'transform: translate' (when it's fixed), the modal, which is positioned\n    // absolutely, takes the dimensions of the header instead of those of the\n    // 'body'.\n    const searchModalEl = document.querySelector(\"header#top .modal#o_search_modal\");\n    if (searchModalEl) {\n        const mainEl = document.querySelector(\"main\");\n        const searchDivEl = document.createElement('div');\n        searchDivEl.id = \"o_search_modal_block\";\n        searchDivEl.appendChild(searchModalEl);\n        mainEl.appendChild(searchDivEl);\n    }\n});\n"], "file": "/web/assets/1/d1ba737/web.assets_frontend_minimal.js", "sourceRoot": "../../../../"}